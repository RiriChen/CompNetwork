# Crypto Echo - Concept Answers

---

## Question 1: TCP vs UDP - Why Stateful Communication Matters

This encryption communication assignment requires the usage of TCP instead of UDP because it provides a stable, connection-oriented session that holds the crypto keys and states between client and server. TCP has essential features: reliable delivery (would retransmit packets lost in transmission), in-order delivery (important in our application where the key-exchange packet must be processed and acknowledged by the server before any encrypted data packets), and a persistent connection abstraction that maps to “one session = one key set.” If we used UDP instead, many things would become problematic. UDP packets are considered independent, meaning a lost or reordered key-exchange datagram would leave client and server out of sync. This asynchronous nature could lead to the client encrypting a message using the key the received, or the server might decrypt with the wrong key. To compensate for UDP’s downsides in our application, we would need to reimplement sequencing, acknowledgements, and retransmissions at the application layer (which is no different than tacking on features that make the protocol essentially TCP). Additionally, UDP’s statelessness complicates key lifecycle management across NATs and retransmissions. The stateful nature of TCP supports session-scoped keys by tying the lifetime of cryptographic state to the TCP connection lifecycle — when the TCP socket closes, that session’s keys and assumptions are torn down automatically.

---

## Question 2: Protocol Data Unit (PDU) Structure Design

We chose a binary PDU with a small header (`msg_type`, `direction`, `payload_len`) followed by a variable payload because it precisely and efficiently describes what is being sent and how it should be interpreted. Sending raw text strings like `"ENCRYPT:Hello World"` is very human-readable but not the best for machines interpretation. Parsing the test requires delimiters or escape handling, it mixes control metadata with the actual payload which could cause confusion, and it fails for binary payloads (encrypted bytes may contain `:` or nulls). A binary header allows unambiguous handling of plaintext, binary encrypted data, and keys. Binary PDUs are compact and can be quickly parsed; the receiver reads the fixed-size header, knows how many payload bytes to read, and branches to the correct handler based on `msg_type`. This structure makes the protocol robust (no ambiguity about where a message ends) and extensible (new message types can be added and work with the older parser). Without a structured header, parsers would need to guess message boundaries which is error-prone, slow for binary content, and hard to extend safely.

---

## Question 3: The Payload Length Field

Because TCP is stream-oriented, it delivers a continuous byte stream with no inherent message boundaries. A single `recv()` call can return part of a PDU, one entire PDU, or several PDUs concatenated together depending on buffering, fragmentation, and timing. The `payload_len` field is critical because it tells the receiver exactly how many bytes make up the payload for the current PDU, so the receiver can loop on `recv()` until it collects the full PDU. Without the `payload_len`attribute, the receiver cannot determine where messages begin and end. Using special delimiters or fixed messages are unreliable and restrictive. If we removed `payload_len` and relied on the semantics of `recv()` to maintain boundaries, code would break whenever TCP split PDUs. Conversely, a large PDU could arrive in multiple `recv()` calls and the code would process an incomplete message, causing decryption or parsing errors. `recv()` simply returns however many bytes are currently available; it does not preserve the conceptual message structure. The explicit length field therefore provides a deterministic, binary-safe framing mechanism essential for reliable parsing and correct cryptographic processing.

---

## Question 4: Key Exchange Protocol and Session State

Making the key exchange session-specific and a preconditioned step ensures security and practical correctness. Hardcoded keys are simple but have many significant security flaws. If the key becomes compromised, every client and server must be notified to change the key to a new unison one. The single compromised key can expose all sessions which are more catastrophic. By generating fresh keys per TCP session, we limit the damage of a compromise (only that session’s traffic is at risk) and enable easy revocation. Session-specific keys also simplify protocol logic; once a TCP connection is established and the client receives its session key, both endpoints can assume the same cryptographic context. If the connection drops after key exchange, that session’s keys become invalid meaning the server and client will discard them. This ties back to TCP: its lifecycle semantics (SYN/FIN/RESET) provide a clear, reliable notion of session boundaries to which key lifetime can attach. With a stateless protocol like UDP, there must be extra implementation of a reliable session establishment, key confirmation, and session binding yourself which can be error-prone and likely insecure if done incorrectly.

---

## Question 5: The Direction Field in the PDU Header

Even though the client and server roles imply who typically sends requests and who sends responses, the explicit `direction` field adds safety, clarity, and debugging capabilities. In debugging (`print_msg_info`) the direction field makes logs self-explanatory. It’s trivial to tell whether a message was intended as a request or a response, which aids diagnosing bugs (for example, a server accidentally sends a request-type PDU to a client which is clearly an incorrect). If request/response handling were swapped by mistake, the direction field provides an immediate protocol-level telltale catch the mismatch early, allowing endpoint code to detect and reject incorrectly oriented PDUs. The direction field also improves self-documentation and futureproofing. In more advanced systems, roles can change dynamically; an explicit direction byte makes it straightforward to support symmetric peers that both request and respond. Finally, the field facilitates middlebox logging, replay detection, and automated tests (test harnesses can assert both type and direction), increasing the protocol’s robustness beyond minimal functionality.
